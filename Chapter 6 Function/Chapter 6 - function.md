## Chapter 6 函数

### 函数基础

- 函数：封装了一段代码，可以在一次执行过程中被反复调用；
  - 函数头：
    - 函数名称——标识符，用于后续的调用
    - 形式参数——代表函数的输入参数
    - 返回类型——函数执行完成后所返回的结果类型

  - 函数体
    - 为一个语句块（block），包含了具体的计算逻辑

- 函数声明与定义
  - 函数声明质保函函数头，不包含函数体，通常置于头文件
  - 函数声明可出现多次，但函数定义通常只能出现一次（存在例外）


- 函数调用
  - 需要提供函数名与实际参数
  - 实际参数拷贝初始化形式参数
  - 返回值会被拷贝给函数的调用者
  - 栈帧结构
- 拷贝过程的（强制）省略
  - 返回值优化
  - C++17强制省略拷贝临时对象
- 函数的外部链接

### 函数详解——参数

- 函数可以在函数头的小括号中包含0到多个形参

  - 包含0个形参时，可以使用void标记
  - 对于非模板函数来说，其每一个形参都有确定的类型，但形参可以没有名称
  - 形参名称的变化并不会映入函数的不同版本
  - 实参到形参的拷贝求值顺序不变，C++17强制省略赋值临时对象

- 函数传值、传址、传引用

- 函数传参过程中的类型退化

- 变长参数

  - initializer_list：可以传入变个数的参数

    ```C++
    #include <initializer_list>
    void fun(std::initializer_list<int> par){
    };
    
    fun({1,2,3,4,5})
    fun({1,2,3})
    ```

  - 可边长度模板参数

  - 使用省略号表示形式参数

- 函数可以定义缺省实参

  - 如果某个形参具有缺省实参，那么它右侧的形参都必须具有缺省实参
  - 在一个翻译单元中，每个形参的缺省实参只能定义一次
  - 具有缺省实参的函数调用时，传入的实参会按照从左到右的顺序匹 配形参数
  - 缺省实参为对象时，实参的缺省值会随对象值的变化而变化

- main函数的两个版本

  - 无形参版本`int main(){}`

  - 带两个形参的版本`int main(int argc, char * argv []){}` // 分别表示实参的个数和实参的数值，argv包含`argc+1`个元素，最后一个元素是null

    `nm ./demo`

### 函数详解——函数体

- 函数体形成域

  - 其中包含了自动对象（内部声明的对象以及形参对象）
  - 也可包含局部静态对象

- 函数体执行完成时的返回

  - 隐式返回
  - 显式返回关键字：return
    - return; 
    - return 表达式;
    - return 初始化表达式;

  - 小心返回自动对象的引用或者指针（对象会销毁）
  - 返回值的优化（RVO）——C++17对返回临时对象的强制优化

### 函数详解——返回类型

- 返回类型表示了函数计算结果的类型，可以为void

- 返回类型的几种书写方式

  - 经典方法：位于函数头的前部

  - C++11引入的方式：位于函数头的后部

    `auto fun(int a) -> int`函数返回类型是int

    `S::MyInt S::fun(int a)`函数返回对象是一个类类型，等价于`auto S::fun(int a) -> MyInt`

  - C++14引入的方式：返回类型的自动推导

    `auto fun(int a){return a+1;} // 返回int类型`

    - 使用constexpr if构造“具有不同返回类型”的函数 // 编译期常量表达式

- 返回类型与结构化绑定（C++17）

- `[[nodiscard]]`属性（C++17）提醒使用者必须用对象接收函数返回值；

### 函数重载与重载解析

- 函数重载：使用相同的函数名定义多个函数，每个函数具有不同的参数列表

  - 不能基于不同的返回类型进行重载
  - 函数重载与name mangling

- 编译器如何选择正确的版本完成函数调用？

  - 参考资源：Calling Functions: A Tutorial

- 名称查找：

  - 限定查找（qualified lookup）与非限定查找（unqualified lookup）
  
    ```C++
    ::fun();//全局空间查找fun()
    MyNS::fun();//调用指定命名空间MyNS中的fun()
    ```
  
  - 非限定查找会进行域的逐级查找——名称隐藏（hiding）
  
  - 查找通常只会在已声明的名称集合中进行
  
  - 实参依赖查找（Argument Dependent lookup: ADL）
    
    - 实参如果在一个名字空间内，函数也会在该名字空间查找
    
    - 只对参数是自定义类型时生效
  
- 重载解析：在名称查找的基础上进一步选择合适的调用函数
  
  - 过滤不能被调用的版本（non-viable candidates）
    - 参数个数不对
    - 无法将实参转化为形参
    - 实参不满足形参的限制条件
  - 在剩余版本中查找与调用表达式最匹配的版本，匹配级别越低越好（有特殊规则）
    - 级别1：完美匹配 或 平凡转换（比如加一个const）
    - 级别2：promotion 或 promotion 加平凡转换
    - 级别3：标准转换 或 标准转换加平凡转换
    - 级别4*：自定义转换 或 自定义转换加平凡转换 或 自定义转换加标准转换
    - 级别5*：调用形参为省略号的版本
    - 函数包含多个形参时，所选函数的所有形参的匹配级别都要优于或等于其它函数
  

### 函数相关的其它内容

- 递归函数：在函数体中调用其自身的函数
  - 通常用于描述复杂的迭代过程
- 内联函数 / constexpr 函数 / consteval 函数
  - `inline void fun()`//链接的时候避免重复定义函数的报错
  - `constexpr`编译期常量
  - `consteval`只能在编译期执行
- 函数指针
  - 函数指针与重载
  - 将函数指针作为函数参数
  - 将函数指针作为函数返回值
  - 小心：most vexing parse
- 



  

















