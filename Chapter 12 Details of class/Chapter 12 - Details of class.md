## Chapter 11 类的细节

### 运算符重载

- 使用operator关键字引入重载函数

  ```c++
  auto operator + (Str x, Str y)
  {
  	Str z;
      z.val = x.val + y.val;
      return z;
  }
  ```

  - 重载不能发明新的运算，不能改变运算的优先级和结和性，通常不改变运算含义
  - 函数参数个数与运算操作数个数相同，至少一个为类类型
  - 除operator()外其它运算符不能有缺省参数
  - 可以选择实现为成员函数与非成员函数
    - 通常来说，时限为成员函数会以*this作为第一个操作数（注意 == 与 <=> 的重载）

- 根据重载特性，可以将运算符进一步划分：

  - 可重载且必须实现为成员函数的运算符（=, [], (), ->与转型运算符）
  - 可重载且可以时限为非成员函数的运算符
  - 可重载但不建议重载的运算符（ &&, ||, 逗号运算符）
    - C++17中规定了相应的求值顺序但没有方式实现短路逻辑

  - 不可重载的运算符（如?:运算符）


### 运算符重载——重载详述1

- 对称运算符通常定义为非成员函数以支持首个操作数的类型转换

- 移位运算符一定要定义为非成员函数，因为其首个操作数类型为流类型

  ```c++
  friend auto& operator << (std::ostream& ostr, Str input)
  {
      ostr << input.val;
      return ostr;
  }
  ```

- 赋值运算符也可以接  收一般参数

```c++
Str& opterator = (const Str& input)
{
    val = input.val;
    return *this;
}
```

- operator[] 通常返回引用
- 自增、自减运算符的前缀、后缀重载方法

```c++
Str& operator ++ () // 前缀自加（++x）
{
    ++val;
    return *this;
}
Str& operator ++ (int) // 后缀自加（x++）
{
    Str tem(*this);
    ++val;
    return tem;
}
```

- 使用解引用运算符（*）与成员访问运算符（->）模拟指针行为
  - 注意“.”运算符不能重载
  - “->”返回指针时会递归调用“->”操作
- 使用函数调用运算符构造可调用对象





